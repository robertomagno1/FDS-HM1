def gb_hist(img_color_double: np.ndarray, num_bins: int = 5) -> np.ndarray:
    """
    Compute the *joint* histogram for the G and B color channels in the image.
    The histogram should be normalized so that sum of all values equals 1,
    assume that values in each channel vary between 0 and 255

    Args:
        img_color_double (np.ndarray): Input color image.
        num_bins (int): Number of bins used to discretize each channel, total number of bins in the histogram should be num_bins^2.

    Returns:
        hists (np.ndarray): Joint histogram.

    E.g. hists[0,9] contains the number of image_color pixels such that:
        - their G values fall in bin 0
        - their B values fall in bin 9
    """
    # Extract the G and B channels
    G = img_color_double[..., 1]  # Green channel
    B = img_color_double[..., 2]  # Blue channel

    # Discretize the channels into bins
    G_bins = np.floor(G / (256 / num_bins)).astype(int) #To discretize these values into bins, we divide each channel's values by the range per bin (which is 256/num_bins).
    B_bins = np.floor(B / (256 / num_bins)).astype(int)

    # Initialize the histogram
    hists = np.zeros((num_bins, num_bins), dtype=float) #dimensions num_binsÃ—num_bins and fill it with zeros.

    # Count occurrences in the histogram
    for g, b in zip(G_bins.flatten(), B_bins.flatten()):
        # Clip values to ensure they are within the valid range
        g = np.clip(g, 0, num_bins - 1)
        b = np.clip(b, 0, num_bins - 1)
        hists[g, b] += 1
    #np.clip(g, 0, num_bins - 1) ensures that the value of g remains within the valid range for the histogram bins. If g is less than 0, it gets set to 0, and if it is greater than num_bins - 1, it gets set to num_bins - 1.

    
    # Normalize the histogram
    total_counts = np.sum(hists)
    if total_counts > 0:
        hists /= total_counts

    return hists.flatten()  # Return a flattened histogram
